#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse
import csv
import math
from pathlib import Path
from statistics import mean, median

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt


def to_float(x: str) -> float | None:
    if x is None:
        return None
    s = str(x).strip()
    if s == "" or s.lower() in {"nan", "none", "null"}:
        return None
    try:
        return float(s)
    except ValueError:
        return None


def percentile(vals: list[float], p: float) -> float:
    a = sorted(vals)
    n = len(a)
    if n == 0:
        return float("nan")
    idx = (n - 1) * p
    lo = int(math.floor(idx))
    hi = int(math.ceil(idx))
    if lo == hi:
        return a[lo]
    return a[lo] + (a[hi] - a[lo]) * (idx - lo)


def summarize(vals: list[float]) -> dict[str, float]:
    if not vals:
        return {"n": 0}
    return {
        "n": len(vals),
        "min": min(vals),
        "p50": percentile(vals, 0.50),
        "p95": percentile(vals, 0.95),
        "max": max(vals),
        "mean": mean(vals),
        "median": median(vals),
    }


def read_csv_numeric(csv_path: Path, col: str) -> list[float]:
    out: list[float] = []
    with csv_path.open("r", encoding="utf-8", newline="") as f:
        r = csv.DictReader(f)
        if r.fieldnames is None or col not in r.fieldnames:
            raise KeyError(f"{csv_path}: column '{col}' not found. columns={r.fieldnames}")
        for row in r:
            v = to_float(row.get(col, ""))
            if v is not None and math.isfinite(v):
                out.append(v)
    return out


def read_csv_series(csv_path: Path, col: str, xcol: str = "trial") -> tuple[list[float], list[float]]:
    xs: list[float] = []
    ys: list[float] = []
    with csv_path.open("r", encoding="utf-8", newline="") as f:
        r = csv.DictReader(f)
        if r.fieldnames is None or col not in r.fieldnames or xcol not in r.fieldnames:
            raise KeyError(f"{csv_path}: need columns '{xcol}' and '{col}'. columns={r.fieldnames}")
        for row in r:
            x = to_float(row.get(xcol, ""))
            y = to_float(row.get(col, ""))
            if x is not None and y is not None and math.isfinite(x) and math.isfinite(y):
                xs.append(x)
                ys.append(y)
    return xs, ys


def plot_hist(vals: list[float], title: str, xlabel: str, out_png: Path, bins: int) -> None:
    plt.figure()
    plt.hist(vals, bins=bins)
    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel("count")
    plt.tight_layout()
    out_png.parent.mkdir(parents=True, exist_ok=True)
    plt.savefig(out_png, dpi=200)
    plt.close()


def plot_box(data: list[list[float]], labels: list[str], title: str, ylabel: str, out_png: Path) -> None:
    plt.figure()
    plt.boxplot(data, tick_labels=labels, showfliers=True)
    plt.title(title)
    plt.ylabel(ylabel)
    plt.tight_layout()
    out_png.parent.mkdir(parents=True, exist_ok=True)
    plt.savefig(out_png, dpi=200)
    plt.close()


def plot_series(xs: list[float], ys: list[float], title: str, xlabel: str, ylabel: str, out_png: Path) -> None:
    plt.figure()
    plt.plot(xs, ys)
    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.tight_layout()
    out_png.parent.mkdir(parents=True, exist_ok=True)
    plt.savefig(out_png, dpi=200)
    plt.close()


def main() -> None:
    ap = argparse.ArgumentParser(description="Plot graphs from qr_tx_log_set*.csv")
    ap.add_argument("--indir", default=".", help="Directory containing csv files (default: current)")
    ap.add_argument("--pattern", default="qr_tx_log_set*.csv", help="Glob pattern (default: qr_tx_log_set*.csv)")
    ap.add_argument("--outdir", default="plots_sets", help="Output directory (default: plots_sets)")
    ap.add_argument("--bins", type=int, default=40, help="Histogram bins (default: 40)")
    ap.add_argument("--no_box", action="store_true", help="Disable boxplot output")
    ap.add_argument("--no_series", action="store_true", help="Disable timeseries plot output")
    args = ap.parse_args()

    indir = Path(args.indir).expanduser().resolve()
    outdir = Path(args.outdir).expanduser().resolve()
    outdir.mkdir(parents=True, exist_ok=True)

    csv_files = sorted(indir.glob(args.pattern))
    if not csv_files:
        raise SystemExit(f"No CSV files matched: {indir}/{args.pattern}")

    metrics = ["txhash_ms", "display_ms", "total_ms"]

    # summary rows
    summary_rows: list[dict[str, object]] = []

    # per-metric per-set data for boxplot
    box_data: dict[str, list[list[float]]] = {m: [] for m in metrics}
    box_labels: list[str] = []

    for csv_path in csv_files:
        label = csv_path.stem  # e.g., qr_tx_log_set1
        box_labels.append(label)

        for m in metrics:
            vals = read_csv_numeric(csv_path, m)
            stat = summarize(vals)
            summary_rows.append({
                "set": label,
                "metric": m,
                **stat,
            })
            # per-set histogram
            out_png = outdir / f"{label}_hist_{m}.png"
            plot_hist(vals, f"{label} {m} histogram (n={stat.get('n',0)})", f"{m} (ms)", out_png, args.bins)
            print(f"[✓] wrote: {out_png}")

            box_data[m].append(vals)

            # timeseries
            if not args.no_series:
                xs, ys = read_csv_series(csv_path, m, "trial")
                out_png2 = outdir / f"{label}_series_{m}.png"
                plot_series(xs, ys, f"{label} {m} timeseries", "trial", f"{m} (ms)", out_png2)
                print(f"[✓] wrote: {out_png2}")

    # boxplots across sets
    if not args.no_box:
        for m in metrics:
            out_png = outdir / f"box_{m}_by_set.png"
            plot_box(box_data[m], box_labels, f"{m} by set (boxplot)", f"{m} (ms)", out_png)
            print(f"[✓] wrote: {out_png}")

    # write summary.csv
    summary_csv = outdir / "summary.csv"
    with summary_csv.open("w", encoding="utf-8", newline="") as f:
        fieldnames = ["set", "metric", "n", "min", "p50", "p95", "max", "mean", "median"]
        w = csv.DictWriter(f, fieldnames=fieldnames)
        w.writeheader()
        for row in summary_rows:
            w.writerow({k: row.get(k, "") for k in fieldnames})
    print(f"[✓] wrote: {summary_csv}")


if __name__ == "__main__":
    main()
